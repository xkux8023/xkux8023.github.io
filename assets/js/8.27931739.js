(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{197:function(t,e,n){"use strict";n.r(e);var r=n(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[n("h3",{attrs:{id:"lru缓存淘汰算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lru缓存淘汰算法","aria-hidden":"true"}},[t._v("#")]),t._v(" LRU缓存淘汰算法")]),t._v(" "),n("blockquote",[n("p",[t._v("如何基于链表实现 LRU 缓存淘汰算法？")])]),t._v(" "),n("p",[t._v("1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入到链表头部；")]),t._v(" "),n("p",[t._v("2.如果此数据没有在缓存链表中，则又可以分为两张情况：")]),t._v(" "),n("ul",[n("li",[t._v("如果此时缓存未满，则将此结点直接插入到链表的头部；")]),t._v(" "),n("li",[t._v("如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部")])])])}],!1,null,null,null);e.default=s.exports}}]);